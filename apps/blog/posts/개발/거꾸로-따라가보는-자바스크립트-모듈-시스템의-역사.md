---
title: 거꾸로 따라가보는 자바스크립트 모듈 시스템의 역사
date: 2026-02-08
---

# JS 어린이 시절

자바스크립트는 원래 꽤 작았다. 서버에서 HTML을 만들면, 클라이언트는 그냥 전달받아서 띄워줬다. 자바스크립트는 버튼 클릭, 링크 같은 상호작용에서만 부분적으로 쓰였다. 모듈 시스템도 없었고, 그냥 필요할 때 `<script>`같이 인라인 스크립트를 선언하거나 스크립트 파일로 사용했다.

### 인턴할 때 실제로 PHP에서 본 코드 🥵 

작년 말 쯤 3주 정도 인턴 했던 곳이 있었는데, 찐 레거시 코드밭이었다. (PHP + Vanilla JS + jQuery + CSS)

스크립트 파일 하나가 3000줄이 넘었고, 개발과 디버깅이 정말 어려웠다. 
일단 변수 참조가 안됨 순서 파악 자체가 안됨. 걍 안됨

파일 상단, 중간, 하단 할 것 없이 이런 스크립트 태그들이 널려있었다. 코드 참조도 안되니 마우스로 따라갈 수도 없다.

```html
<script src="jquery.js"></script>
<!-- ... -->

<script src="jquery-ui.js"></script>
<script src="main-header.js"></script>
<script src="user-profile.js"></script>
<!-- ... -->

<script src="footer-logic.js"></script>
<script src="analytics.js"></script>
<script src="global-utils.js"></script>
<!-- ... -->
```
### 간단한 예제로 살펴보기

HTML에 이런 스크립트들이 있다.

```html
<!DOCTYPE html> 
<html lang="ko"> 
  <title>Bundler deep dive 💝</title>
  <head> 
    <script src="script-1.js"></script> 
    <script src="script-2.js"></script> 
    <script src="console-log.js"></script> 
  </head> 
</html>
```

`script-1.js`에선 `a`에 1을 넣는다.
```js
// script-1.js
var a = 1;
```

다른 파일에서 같은 이름의 변수를 선언해도 오류가 나지 않고
```js
// script-2.js
var a = 2;
```

`console-log.js`에서 앞에서 무슨 일이 일어났는지도 영문도 모른 채 `a`를 찍어보면 2가 나온다.
```js
// console-log.js
console.log(a); // 2
```

`script-1.js`과 `script-2.js` 스크립트의 순서를 바꿔보면?

```html
<!DOCTYPE html> 
<html lang="en"> 
  <title>Bundler deep dive 👍</title>
  <head> 
    <script src="script-1.js"></script> 
    <script src="console-log.js"></script> 
    <script src="script-2.js"></script> 
  </head> 
</html>
```

`console-log.js`에서 `a`가 1이 나온다.
```js
// console-log.js
console.log(a); // 1
```

`defer`나 `async`가 붙지 않은 일반 스크립트는 브라우저에서 동기적으로 실행되므로 스크립트가 선언된 순서에 의존하기 때문이다.

>변수 하나도 헷갈리는데 프로젝트가 커지고 변수들이 점점 많아지면?

![대환장 파티](/posts/2026-02-08/party.jpg)

### 궁금증 1: 

>var 키워드로 선언한 같은 이름의 변수가 여러 개일 때 왜 오류가 안날까? `var a = 1`, `var a = 3`처럼

자바스크립트 엔진은 스크립트를 실행하기 전에 **전역 실행 컨텍스트**를 만드는데 이때 **전역 객체(window)** 가 생성된다. var 키워드로 선언된 변수는 `undefined`라는 값과 함께 여기에 미리 등록된다. 이후 자바스크립트 실행 시점에 값이 할당된다. 그래서 이 변수는 전역 객체 스코프를 가진다. 

자바스크립트 엔진이 다시 `var a = 2`를 만나면 먼저 전역 객체 window 를 확인한 뒤에 이미 `window.a`가 있다면 초기화 단계를 건너뛰고 값만 할당한다. 

하여간 이 var 키워드 변수를 무분별하게 사용하다보니 전역 변수가 충돌되고 예측하기도 힘들어졌다.

### 궁금증 2: 모듈 시스템의 필요성은 언제 제기되었을까?

함수 스코프를 가지는 let, const 이전에는 IIFE(즉시 실행 함수)로 스코프를 제한했다.

전역 스코프의 문제를 해결하는 let과 const 키워드가 비교적 최근(?)인 ES6(2015년)에서 등장했는데, 그럼 **개발자들이 모듈 시스템의 필요성을 느낀 시점은 그보다 훨씬 이전이 아닐까?** 라는 생각이 들었다. 

Gemini한테 물어보니 2009년 node.js의 등장을 언급했다.

>뭐야 그럼 모듈화에 대한 니즈는 결국 서버에서 먼저 시작된거야? 그럼 자바스크립트 모듈 시스템의 역사를 알려면 node.js를 먼저 살펴봐야겠네? 근데 원래 서버에서는 자바스크립트 안 쓰지 않았어?

이런 궁금증이 생겼다. 매번 Ajax, SPA 등장 같이 클라이언트 측의 발전 과정만 접했다보니 서버 측에 대해선 생각을 못해봤다.

### Node.js 등장 당시의 상황

자료를 찾아보니 더 많은 자바스크립트와 여러 모듈을 필요로 하는 서버 측에서 먼저 모듈 시스템의 필요성이 제기되었다는 걸 알았다. 2009년 Node.js가 등장하기 전 이미 Common JS라는 모듈 규약이 활발하게 논의되고 있었고, Node.js가 이를 표준으로 받아들인 것이다. 

또한, 2005년 Google이 구글 맵스를 통해 발표한 Ajax가 대중화되면서 브라우저에서 실행될 자바스크립트의 양 자체가 많아지게 됐다. 하지만 당시 브라우저는 자바스크립트를 실행하는 속도가 느려서 이런 복잡한 웹 앱을 돌리기 버거웠고, 2008년 구글은 V8 엔진을 만들어 내놓았다. node.js는 V8을 자바스크립트 엔진으로 채택했다.

# Common JS의 등장 

2009년 크리스 코왈은 당시 문제점을 이렇게 말했다.

- 모듈 시스템이 없다. 스코프 격리나 의존성 관리를 위한 기능이 없다.
- 표준 라이브러리가 없다. 파일 시스템, 입출력 스트림 API나 이진 데이터를 위한 기본적인 데이터 유형조차 없다.
- 웹 서버나 DB와 같은 것들에 대한 표준 인터페이스를 가지고 있지 않다.
- 패키지 관리 시스템이 없다.

Kevin Dangoor은 서버 사이드에서 자바스크립트가 더 발전하려면 **표준을 정해야 한다!** 고 주장했고 함께 할 사람들을 모았다. https://groups.google.com/g/commonjs?pli=1 당시 사람들이 논의하던 구글 그룹인데, 페이지를 넘겨보면 Server JS에서 어느순간 Common JS로 이름이 바뀐 것을 볼 수 있다.


## Common JS 간단히 살펴보기

CommonJS에서 모듈은 하나의 파일을 가리킨다. <br/>
`exports`라는 객체를 통해 내보낼 값을 모듈의 루트에 추가한다.

```js
// math.js
module.exports.add = (a, b) => a + b; 
```

`require('./math.js')`은 `math.js` 파일을 찾고, 한 번 실행한 다음, 그 파일의 `module.exports` 값을 반환한다.

```js
const math = require('./math.js'); 

console.log(math.multiply(2, 3)); // 6
```

또 다른 특징은 모듈이 동기적으로 실행된다는 것이다.

```javascript
// module1.js
console.log('module1 로드 시작')

setTimeout(() => {
  console.log('module1 실행')
}, 2000)

console.log('module1')
```

```javascript
// index.js
console.log('시작')
const module1 = require('./module1')
console.log('index!')
console.log('종료')
```

이 코드의 실행 결과는 어떻게 될까?

```bash
시작
module1 로드 시작
module1
index!
종료
module1 실행
```

### 동기 실행의 문제

서버에서는 파일 시스템의 접근이 빨라서 모듈이 동기적으로 실행돼도 괜찮다. 하지만 브라우저에서는 그렇지 않다. 네트워크 요청을 통해 스크립트를 받아야 하는데, 스크립트를 받기까지의 시간이 너무 오래 걸린다. 필요한 모듈들을 가져오는 동안 브라우저는 그냥 기다려야 한다.

## AMD(Asynchronous Module Definition)

그래서 비동기 방식의 모듈 시스템이 필요하다는 목소리가 커졌다. 그리고 AMD가 등장했다. 

아래 AMD의 define을 보면 `require`, `exports`처럼 간단하게 사용했던 Common JS보다 조금 더 복잡한데, 필요한 모듈들을 나열하고 다 가져오고나서 콜백으로 실행해야 하기 때문이다. 

```js
define("alpha", ["require", "exports", "beta"], function (require, exports, beta) { // 모듈의 내용 });
```

### CommonJS와 AMD가 갈라서는 장면

실제로 그룹 메일에서 CommonJS와 AMD가 갈라서는 토론 현장을 찾았다. *'서버만 고려하면서 왜 CommonJS로 이름 바꿨냐!'* 면서 오만하다는 개발자의 의견도 보인다.

https://groups.google.com/g/commonjs/c/lqCWO8tMp48/m/gRqjWVP4364J

Gemini한테 요약해달라고 던져줘봤다.

- **CommonJS 진영:** "우리는 서버에서 잘 돌아가는 표준을 만들고 싶다. 브라우저는 나중에 기술이 발전하면 해결될 문제다." (동기 방식 고수)

- **AMD 진영 (James Burke 등):** "지금 당장 브라우저 비동기 환경에서 대규모 앱을 돌려야 한다. 서버 방식은 브라우저에서 너무 느리고 디버깅도 힘들다." (비동기 방식 필요)

#### 결론: 우리 헤어졌어요

- Kris Kowal (CommonJS 핵심 멤버): 둘은 진화가 아니라 아예 재시작 수준으로 다르다. 합치려 노력해봤자 혼란만 주니, AMD는 이제 CommonJS라는 이름을 쓰지 말고 독립해서 나가라.

이후 AMD 사양을 채택한 Require JS같은 라이브러리가 등장했다. Common JS는 Node.js에서, AMD는 Require.js에서 채택한 것이다.

# 우리도 node.js처럼 코드 짜고 싶어요 ‼️

### AMD 쓰다가 개빡친 개발자의 글

https://codeofrob.com/entries/why-i-stopped-using-amd.html

- *AMD that looks like somebody vomitted in my Javascripts* (누가 내 자바스크립트에 토한 것 같다)
- 프로젝트가 커질수록 RequireJS 설정 파일이 수백 줄이 되고, 문서는 읽기 힘들 정도로 난해해진다.
- "이 라이브러리 AMD 지원하나?"를 매번 확인해야 한다. 지원 안 하면 `shim`이라는 설정을 따로 적어줘야 하는데, 이게 정말 귀찮고 에러가 많이 난다.
- AMD가 브라우저 로딩 속도를 위해 비동기를 택했지만, 사실 모듈이 다 로드되기 전까지는 프로그램이 실행될 수 없다는 점에서 비동기 관리 자체가 불필요한 오버헤드이다.

**이 개발자 Browserify로 갈아탔다고 합니다..**

### Broswerify를 쓰면?

Node.js에서 채택한 CommonJS는 AMD에 비해 문제가 적고, 명확하고, 관리도 쉬웠다. 

2010년, Browserify는 클라이언트에서도 node.js 스타일로 코드를 작성하고 싶다는 니즈에서 등장했다. node.js 스타일로 `require('./hello-world.js')`같은 코드를 짜면, Broswerify가 변환이 필요한 파일을 재귀적으로 싹 다 찾아낸 뒤 브라우저가 읽을 수 있는 하나의 큰 번들로 만들어준다.

### Webpack은 왜 나왔을까?

#### broswerify의 한계

2012년, Broswerify의 후발 주자로 Webpack이 나왔다.

Broswerify는 자바스크립트의 require만 해석할 수 있다. `require('./style.css')`, `require('./alarm-icon.png')` 이건 안 된다. 

```js
// Browserify
const imgTag = document.getElementById('alarm-icon'); 

imgTag.src = '/assets/images/alarm.png'; // 뭐 파일 있겠지?
```

또한 단일 번들 파일을 생성하므로, 번들이 커지면 초기 로딩이 느려지는 문제점이 있었다.

#### Webpack은?

Webpack은 로더를 이용해 자바스크립트 뿐만 아니라 CSS, png 같은 이미지 등 모든 정적 자산을 JS 안에서 가져올 수 있도록 했다.

```js
// alarmIcon은 Webpack이 관리하는 모듈
var alarmIcon = require('./alarm.png'); 

var imgTag = document.createElement('img'); 
imgTag.src = alarmIcon;
document.body.appendChild(imgTag);
```

# 드디어 자바스크립트 표준이 나오다

2015년, 드디어 ECMA에서 **ESM(ECMAScript Modules)** 사양을 발표했다. 이제 서로 싸우고 있는 `require`, `define` 같은 사설 규격이 아닌 공식적으로 자바스크립트에 내장된 `import`, `export`을 사용할 수 있게 됐다.

### 가지치기(tree-shaking)가 가능해짐

ESM의 등장으로 트리셰이킹이 가능해졌다. Common JS의 `require()`은 어디서든 호출할 수 있었기 때문에 코드를 실행하기 전에는 쓰일 지 안 쓰일 지 알기가 어려웠다. 하지만 `import`, `export` 문은 스크립트 최상단에서만 쓸 수 있기 때문에 번들러가 모듈들의 의존 관계를 파악해 쓰이지 않는 코드를 쳐낼 수 있게 됐다.
 

# 번들러의 역할

마지막으로 번들러의 역할을 살펴보자.

1. HTML의 `<script type="module">`에 넣을 **주요(main) 모듈(진입점 역할을 하는 모듈)을 선택**한다.
2. 주요 모듈에 의존하고 있는 모듈 분석을 시작으로 모듈 간의 **의존 관계를 파악**한다.
3. 모듈 전체를 한데 모아 하나의 큰 파일을 만든다(설정에 따라 여러 개의 파일을 만드는 것도 가능하다 ⇒ **코드 스플리팅**). 이 과정에서 `import`문이 번들러 내 함수로 대체되므로 기존 기능은 그대로 유지된다. 하나로 합치면 초기 로딩이 너무 느려지는 경우 사용한다.
4. 이런 과정 중에 변형이나 최적화도 함께 수행된다.
- 도달 가능하지 않은 코드를 삭제한다.
- 내보내진 모듈 중 쓰임처가 없는 모듈을 삭제한다.
- `console`, `debugger` 같은 개발 관련 코드 삭제
```jsx
    // vite.config.js
    export default {
      esbuild: {
        drop: ['console', 'debugger'],
      },
    };
```
    
- 최신 자바스크립트 문법이 사용된 경우 [바벨(Babel)](https://babeljs.io/)을 사용해 동일한 기능을 하는 낮은 버전의 스크립트로 변환
- 공백 제거, 변수 이름 줄이기 등 ⇒ 산출물의 크기를 줄임
- 즉, 번들링 과정이 끝나면 기존 스크립트에서 `import`, `export`가 사라지기 때문에 `type="module"`이 필요 없어진다. 하지만 네이티브 모듈도 당연히 사용 가능하다.
```html
    <!-- 웹팩과 같은 툴로 번들링 과정을 거친 스크립트인 bundle.js -->
    <script src="bundle.js"></script>
```

# 참고 자료

- https://d2.naver.com/helloworld/12864
- https://arstechnica.com/information-technology/2009/12/commonjs-effort-sets-javascript-on-path-for-world-domination/
- https://groups.google.com/g/commonjs?pli=1
- [CommonJS](http://commonjs.org/)
- https://yceffort.kr/2023/05/what-is-commonjs
- https://github.com/browserify/browserify#usage
- https://codeofrob.com/entries/why-i-stopped-using-amd.html
- https://coderifleman.tumblr.com/post/112564054684/browserify%EC%99%80-webpackhttps://velog.io/@jong-kyung/%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-%EB%B2%88%EB%93%A4%EB%9F%AC%EC%9D%98-%EB%AA%A8%EB%93%A0-%EA%B2%83