

## 모듈이 없던 시절 이해하기

1. **전역 스코프 오염 문제** — `<script>` 태그를 여러 개 나열하던 방식, 변수 충돌 문제
2. **초기 패턴들** — IIFE(즉시실행함수), Revealing Module Pattern, Namespace 패턴
3. 이 패턴들이 왜 한계가 있었는지 직접 느껴보기 (간단한 예제 작성 추천)

## Phase 2: 모듈 시스템의 등장

4. **CommonJS (CJS)** — Node.js가 채택한 방식, `require` / `module.exports`, 동기 로딩의 특성과 서버 환경에 적합한 이유
5. **AMD (Asynchronous Module Definition)** — RequireJS, `define` / `require`, 브라우저 환경의 비동기 로딩 문제를 해결하려 한 시도
6. **UMD (Universal Module Definition)** — CJS와 AMD를 동시에 지원하려는 호환 래퍼, 라이브러리 배포 시 왜 쓰였는지

## Phase 3: 표준의 탄생

7. **ES Modules (ESM)** — `import` / `export`, 정적 분석이 가능한 구조, `<script type="module">`, Top-level await
8. **CJS vs ESM 비교** — 정적 vs 동적, 값 복사 vs 라이브 바인딩, 순환 참조 처리 차이
9. **Node.js에서의 ESM 도입 과정** — `.mjs` 확장자, `package.json`의 `"type": "module"`, 듀얼 패키지 문제

## Phase 4: 번들러가 필요한 이유

10. **왜 번들링이 필요한가** — HTTP 요청 수 문제(HTTP/1.1), 브라우저 호환성, Node 모듈을 브라우저에서 쓰기, 코드 변환(트랜스파일) 필요성
11. **번들러의 핵심 개념** — 의존성 그래프(Dependency Graph), 엔트리 포인트, 청크, 로더/플러그인